
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>View and Writer Types &#8212; Velox  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="How to add a lambda function?" href="lambda-functions.html" />
    <link rel="prev" title="How to add an aggregate function?" href="aggregate-functions.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="lambda-functions.html" title="How to add a lambda function?"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="aggregate-functions.html" title="How to add an aggregate function?"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" accesskey="U">Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">View and Writer Types</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="view-and-writer-types">
<h1>View and Writer Types<a class="headerlink" href="#view-and-writer-types" title="Permalink to this heading">¶</a></h1>
<p>View types and writer types are used as the input and output parameter types
respectively for complex and string types in the simple function interface of
both scalar and aggregate functions.</p>
<section id="inputs-view-types">
<h2>Inputs (View Types)<a class="headerlink" href="#inputs-view-types" title="Permalink to this heading">¶</a></h2>
<p>Input complex types are represented in the simple function interface using light-weight lazy
access abstractions that enable efficient direct access to the underlying data in Velox
vectors.
As mentioned earlier, the helper aliases arg_type and null_free_arg_type can be used in function’s signatures to
map Velox types to the corresponding input types. The table below shows the actual types that are
used to represent inputs of different complex types.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>C++ Argument Type</p></th>
<th class="head"><p>C++ Actual Argument Type</p></th>
<th class="head"><p>Corresponding <cite>std</cite> type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>arg_type&lt;Array&lt;E&gt;&gt;</p></td>
<td><p>NullableArrayView&lt;E&gt;&gt;</p></td>
<td><p>std::vector&lt;std::optional&lt;V&gt;&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>arg_type&lt;Map&lt;K,V&gt;&gt;</p></td>
<td><p>NullableMapView&lt;K, V&gt;</p></td>
<td><p>std::map&lt;K, std::optional&lt;V&gt;&gt;</p></td>
</tr>
<tr class="row-even"><td><p>arg_type&lt;Row&lt;T…&gt;&gt;</p></td>
<td><p>NullableRowView&lt;T…&gt;</p></td>
<td><p>std::tuple&lt;std::optional&lt;T&gt;…</p></td>
</tr>
<tr class="row-odd"><td><p>null_free_arg_type&lt;Array&lt;E&gt;&gt;</p></td>
<td><p>NullFreeArrayView&lt;E&gt;</p></td>
<td><p>std::vector&lt;V&gt;</p></td>
</tr>
<tr class="row-even"><td><p>null_free_arg_type&lt;Map&lt;K,V&gt;&gt;</p></td>
<td><p>NullFreeMapView&lt;K, V&gt;</p></td>
<td><p>std::map&lt;K, V&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>null_free_arg_type&lt;Row&lt;T…&gt;&gt;&gt;</p></td>
<td><p>NullFreeRowView&lt;T…&gt;</p></td>
<td><p>std::tuple&lt;T…&gt;</p></td>
</tr>
</tbody>
</table>
<p>The view types are designed to have interfaces similar to those of std::containers, in fact in most cases
they can be used as a drop in replacement. The table above shows the mapping between the Velox type and
the corresponding std type. For example: a <em>Map&lt;Row&lt;int, int&gt;, Array&lt;float&gt;&gt;</em> corresponds to const
<em>std::map&lt;std:::tuple&lt;int, int&gt;, std::vector&lt;float&gt;&gt;</em>.</p>
<p>All views types are cheap to copy objects, for example the size of ArrayView is 16 bytes at max.</p>
<p><strong>OptionalAccessor&lt;E&gt;</strong>:</p>
<p>OptionalAccessor is an <em>std::optional</em> like object that provides lazy access to the nullity and
value of the underlying Velox vector at a specific index. Currently, it is used to represent elements of nullable input arrays
and values of nullable input maps. Note that keys in the map are assumed to be always not nullable in Velox.</p>
<p>The object supports the following methods:</p>
<ul class="simple">
<li><p>arg_type&lt;E&gt; value()      : unchecked access to the underlying value.</p></li>
<li><p>arg_type&lt;E&gt; operator *() : unchecked access to the underlying value.</p></li>
<li><p>bool has_value()         : return true if the value is not null.</p></li>
<li><p>bool operator()          : return true if the value is not null.</p></li>
</ul>
<p>The nullity and the value accesses are decoupled, and hence if someone knows inputs are null-free,
accessing the value does not have the overhead of checking the nullity. So is checking the nullity.
Note that, unlike std::container, function calls to value() and operator* are r-values (temporaries) and not l-values,
they can bind to const references and l-values but not references.</p>
<p>OptionalAccessor&lt;E&gt; is assignable to and comparable with std::optional&lt;arg_type&lt;E&gt;&gt; for primitive types.
The following expressions are valid, where array[0] is an optional accessor.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">if</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">)</span><span class="w"> </span><span class="p">...</span>
<span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="p">...</span>
<span class="k">if</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">})</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p><strong>NullableArrayView&lt;T&gt; and NullFreeArrayView&lt;T&gt;</strong></p>
<p>NullableArrayView and NullFreeArrayView have interfaces similar to that of <em>std::vector&lt;std::optional&lt;V&gt;&gt;</em> and <em>std::vector&lt;V&gt;</em>,
the code below shows the function arraySum, a range loop is used to iterate over the values.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ArraySum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VELOX_DEFINE_FUNCTION_TYPES</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">call</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">element</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>ArrayView supports the following:</p>
<ul class="simple">
<li><p>size_t <strong>size</strong> () : return the number of elements in the array.</p></li>
<li><p><strong>operator[]</strong> (size_t index) : access element at index. It returns either null_free_arg_type&lt;T&gt; or OptionalAccessor&lt;T&gt;.</p></li>
<li><p>ArrayView&lt;T&gt;::Iterator <strong>begin</strong> () : iterator to the first element.</p></li>
<li><p>ArrayView&lt;T&gt;::Iterator <strong>end</strong> () : iterator indicating end of iteration.</p></li>
<li><p>bool <strong>mayHaveNulls</strong> () : constant time check on the underlying vector nullity. When it returns false, there are definitely no nulls, a true does not guarantee null existence.</p></li>
<li><p>ArrayView&lt;T&gt;::SkipNullsContainer <strong>skipNulls</strong> () : return an iterable container that provides direct access to non-null values in the underlying array. For example, the function above can be written as:</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ArraySum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VELOX_DEFINE_FUNCTION_TYPES</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">call</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">skipNulls</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The skipNulls iterator will check the nullity at each index and skip nulls, a more performant implementation
would skip reading the nullity when mayHaveNulls() is false.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ArraySum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">VELOX_DEFINE_FUNCTION_TYPES</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">call</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="n">mayHaveNulls</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">skipNulls</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// No nulls, skip reading nullity.</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">element</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note: calls to operator[], iterator de-referencing, and iterator pointer de-referencing are r-values (temporaries),
versus l-values in STD containers. Hence those can be bound to const references or l-values but not normal references.</p>
<p><strong>NullableMapView&lt;K, V&gt; and  NullFreeMapView&lt;K, V&gt;</strong></p>
<p>NullableMapView and NullFreeMapView has an interfaces similar to std::map&lt;K, std::optional&lt;V&gt;&gt; and std::map&lt;K, V&gt;,
the code below shows an example function mapSum, sums up the keys and values.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MapSum</span><span class="p">{</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">call</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="p">,</span><span class="w"> </span><span class="kt">int64_t</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>MapView supports the following:</p>
<ul class="simple">
<li><p>MapView&lt;K,V&gt;::Element <strong>begin</strong> () : iterator to the first map element.</p></li>
<li><p>MapView&lt;K,V&gt;::Element <strong>end</strong> ()   : iterator that indicates end of iteration.</p></li>
<li><p>size_t <strong>size</strong> ()                 : number of elements in the map.</p></li>
<li><p>MapView&lt;K,V&gt;::Iterator <strong>find</strong> (const key_t&amp; key): performs a linear search for the key, and returns iterator to the element if found otherwise returns end(). Only supported for primitive key types.</p></li>
<li><p>MapView&lt;K,V&gt;::Iterator <strong>operator[]</strong> (const key_t&amp; key): same as find, throws an exception if element not found.</p></li>
<li><p>MapView&lt;K,V&gt;::Element</p></li>
</ul>
<p>MapView&lt;K, V&gt;::Element is the type returned by dereferencing MapView&lt;K, V&gt;::Iterator. It has two members:</p>
<ul class="simple">
<li><p>first : arg_type&lt;K&gt; | null_free_arg_type&lt;K&gt;</p></li>
<li><p>second: OptionalAccessor&lt;V&gt; | null_free_arg_type&lt;V&gt;</p></li>
<li><p>MapView&lt;K, V&gt;::Element participates in struct binding: auto [v, k] = *map.begin();</p></li>
</ul>
<p>Note: iterator de-referencing and iterator pointer de-referencing result in temporaries. Hence those can be bound to
const references or value variables but not normal references.</p>
<p>Generic&lt;T1&gt; input types are implemented using GenericView that supports the following:</p>
<ul class="simple">
<li><p>uint64_t <strong>hash</strong> () const : returns a hash of the value; used to define std::hash&lt;GenericView&gt;(); allows GenericView’s to be stored in folly::F14 sets and maps as well as STL’s sets and maps.</p></li>
<li><p>bool <strong>isNull</strong> () const   : returns true if the value is NULL</p></li>
<li><p>bool <strong>operator==</strong> (const GenericView&amp; other) const : equality comparison with another GenericView</p></li>
<li><p>std::optional&lt;int64_t&gt; <strong>compare</strong> (const GenericView&amp; other, const CompareFlags flags) const : comparison with another GenericView</p></li>
<li><p>TypeKind <strong>kind</strong> () const : returns TypeKind of the value</p></li>
<li><p>const TypePtr&amp; <strong>type</strong> () const : returns Velox type of the value</p></li>
<li><p>std::string <strong>toString</strong> () const : returns string representaion of the value for logging and debugging</p></li>
<li><p>template &lt;typename ToType&gt; typename VectorReader&lt;ToType&gt;::exec_in_t <strong>castTo</strong> () const : cast to concrete view type</p></li>
<li><p>template &lt;typename ToType&gt; std::optional&lt;typename VectorReader&lt;ToType&gt;::exec_in_t&gt; <strong>tryCastTo</strong> () const : best-effort attempt to cast to a concrete view type</p></li>
</ul>
<p><strong>Temporaries lifetime C++</strong></p>
<p>While c++ allows temporaries(r-values) to bound to const references by extending their lifetime, one must be careful and
know that only the assigned temporary lifetime is extended but not all temporaries in the RHS expression chain.
In other words, the lifetime of any temporary within an expression is not extended.</p>
<p>For example, for the expression const auto&amp; x = map.begin()-&gt;first.
c++ does not extend the lifetime of the result of map.begin() since it’s not what is being
assigned. And in such a case, the assignment has undefined behavior.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Safe assignments. single rhs temporary.</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>

<span class="c1">// Unsafe assignments. (undefined behaviours)</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">**</span><span class="n">it</span><span class="p">;</span>

<span class="c1">// Safe and cheap to assign to value.</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">**</span><span class="n">it</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that in the range-loop, the range expression is assigned to a universal reference. Thus, the above concern applies to it.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Unsafe range loop.</span>
<span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">**</span><span class="n">it</span><span class="p">){..}</span>

<span class="c1">// Safe range loop.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">itt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="n">itt</span><span class="p">){..}</span>
</pre></div>
</div>
</section>
<section id="outputs-writer-types">
<span id="outputs-write"></span><h2>Outputs (Writer Types)<a class="headerlink" href="#outputs-writer-types" title="Permalink to this heading">¶</a></h2>
<p>Outputs of complex types are represented using special writers that are designed in a way that
minimizes data copying by writing directly to Velox vectors.</p>
<p><strong>ArrayWriter&lt;V&gt;</strong></p>
<ul class="simple">
<li><p>out_type&lt;V&gt;&amp; <strong>add_item</strong> () : add non-null item and return the writer of the added value.</p></li>
<li><p><strong>add_null</strong> (): add null item.</p></li>
<li><p><strong>reserve</strong> (vector_size_t size): make sure space for <cite>size</cite> items is allocated in the underlying vector.</p></li>
<li><p>vector_size_t <strong>size</strong> (): return the length of the array.</p></li>
<li><p><strong>resize</strong> (vector_size_t size): change the size of the array reserving space for the new elements if needed.</p></li>
<li><p>void <strong>add_items</strong> (const T&amp; data): append data from any container with std::vector-like interface.</p></li>
<li><p>void <strong>copy_from</strong> (const T&amp; data): assign data to match that of any container with std::vector-like interface.</p></li>
<li><p>void <strong>add_items</strong> (const NullFreeArrayView&lt;V&gt;&amp; data): append data from array view (faster than item by item).</p></li>
<li><p>void <strong>copy_from</strong> (const NullFreeArrayView&lt;V&gt;&amp; data): assign data from array view (faster than item by item).</p></li>
<li><p>void <strong>add_items</strong> (const NullableArrayView&lt;V&gt;&amp; data): append data from array view (faster than item by item).</p></li>
<li><p>void <strong>copy_from</strong> (const NullableArrayView&lt;V&gt;&amp; data): assign data from array view (faster than item by item).</p></li>
</ul>
<p>When V is primitive, the following functions are available, making the writer usable as std::vector&lt;V&gt;.</p>
<ul class="simple">
<li><p><strong>push_back</strong> (std::optional&lt;V&gt;): add item or null.</p></li>
<li><p>PrimitiveWriter&lt;V&gt; <strong>operator[]</strong> (vector_size_t index): return a primitive writer that is assignable to std::optional&lt;V&gt; for the item at index (should be called after a resize).</p></li>
<li><p>PrimitiveWriter&lt;V&gt; <strong>back</strong> (): return a primitive writer that is assignable to std::optional&lt;V&gt; for the item at index length -1.</p></li>
</ul>
<p><strong>MapWriter&lt;K, V&gt;</strong></p>
<ul class="simple">
<li><p><strong>reserve</strong> (vector_size_t size): make sure space for <cite>size</cite> entries is allocated in the underlying vector.</p></li>
<li><p>std::tuple&lt;out_type&lt;K&gt;&amp;, out_type&lt;V&gt;&amp;&gt; <strong>add_item()</strong> : add non-null item and return the writers of key and value as tuple.</p></li>
<li><p>out_type&lt;K&gt;&amp; <strong>add_null()</strong> : add null item and return the key writer.</p></li>
<li><p>vector_size_t <strong>size</strong> (): return the length of the map.</p></li>
<li><p>void <strong>add_items</strong> (const T&amp; data): append data from any container with std::vector&lt;tuple&lt;K, V&gt;&gt; like interface.</p></li>
<li><p>void <strong>copy_from</strong> (const NullFreeMapView&lt;V&gt;&amp; data): assign data from map view (faster than item by item).</p></li>
<li><p>void <strong>copy_from</strong> (const NullableMapView&lt;V&gt;&amp; data): assign data from map view (faster than item by item).</p></li>
</ul>
<p>When K and V are primitives, the following functions are available, making the writer usable as std::vector&lt;std::tuple&lt;K, V&gt;&gt;.</p>
<ul class="simple">
<li><p><strong>resize</strong> (vector_size_t size): change the size.</p></li>
<li><p><strong>emplace</strong> (K, std::optional&lt;V&gt;): add element to the map.</p></li>
<li><p>std::tuple&lt;K&amp;, PrimitiveWriter&lt;V&gt;&gt; <strong>operator[]</strong> (vector_size_t index): returns pair of writers for element at index. Key writer is assignable to K. while value writer is assignable to std::optional&lt;V&gt;.</p></li>
</ul>
<p><strong>RowWriter&lt;T…&gt;</strong></p>
<ul class="simple">
<li><p>template&lt;vector_size_t I&gt; <strong>set_null_at</strong> (): set null for row item at index I.</p></li>
<li><p>template&lt;vector_size_t I&gt; <strong>get_writer_at</strong> (): set not null for row item at index I, and return writer to the row element at index I.</p></li>
</ul>
<p>When all types T… are primitives, the following functions are available.</p>
<ul class="simple">
<li><p>void <strong>operator=</strong> (const std::tuple&lt;T…&gt;&amp; inputs): assignable to std::tuple&lt;T…&gt;.</p></li>
<li><p>void <strong>operator=</strong> (const std::tuple&lt;std::optional&lt;T&gt;…&gt;&amp; inputs): assignable to std::tuple&lt;std::optional&lt;T&gt;…&gt;.</p></li>
<li><p>void <strong>copy_from</strong> (const std::tuple&lt;K…&gt;&amp; inputs): similar as the above.</p></li>
</ul>
<p>When a given Ti is primitive, the following is valid.</p>
<ul class="simple">
<li><p>PrimitiveWriter&lt;Ti&gt; exec::get&lt;I&gt;(RowWriter&lt;T…&gt;): return a primitive writer for item at index I that is assignable to std::optional.</p></li>
</ul>
<p><strong>PrimitiveWriter&lt;T&gt;</strong></p>
<p>Assignable to std::optional&lt;T&gt; allows writing null or value to the primitive. Returned by complex writers when writing nullable
primitives.</p>
<p><strong>StringWriter&lt;&gt;</strong></p>
<ul class="simple">
<li><p>void <strong>reserve</strong> (size_t newCapacity) : Reserve a space for the output string with size of at least newCapacity.</p></li>
<li><p>void <strong>resize</strong> (size_t newCapacity) : Set the size of the string.</p></li>
<li><p>char* <strong>data</strong> (): returns pointer to the first char of the string, can be written to directly (safe to write to index at capacity()-1).</p></li>
<li><p>vector_size_t <strong>capacity</strong> (): returns the capacity of the string.</p></li>
<li><p>vector_size_t <strong>size</strong> (): returns the size of the string.</p></li>
<li><p><strong>operator+=</strong> (const T&amp; input): append data from char* or any type with data() and size().</p></li>
<li><p><strong>append</strong> (const T&amp; input): append data from char* or any type with data() and size().</p></li>
<li><p><strong>copy_from</strong> (const T&amp; input): append data from char* or any type with data() and size().</p></li>
</ul>
<p>When Zero-copy optimization is enabled (see zero-copy-string-result section above), the following functions can be used.</p>
<ul class="simple">
<li><p>void <strong>setEmpty</strong> (): set to empty string.</p></li>
<li><p>void <strong>setNoCopy</strong> (const StringView&amp; value): set string to an input string without performing deep copy.</p></li>
</ul>
<p><strong>GenericWriter</strong></p>
<ul class="simple">
<li><p>TypeKind <strong>kind</strong> () const : returns TypeKind of the value</p></li>
<li><p>const TypePtr&amp; <strong>type</strong> () const : returns Velox type of the value</p></li>
<li><p>void <strong>copy_from</strong> (const GenericView&amp; view) : assign data from another GenericView</p></li>
<li><p>template &lt;typename ToType&gt; typename VectorWriter&lt;ToType, void&gt;::exec_out_t&amp; <strong>castTo</strong> () : cast to concrete writer type</p></li>
<li><p>template &lt;typename ToType&gt; typename VectorWriter&lt;ToType, void&gt;::exec_out_t* <strong>tryCastTo</strong> () : best-effort attempt to cast to a concrete writer type</p></li>
</ul>
</section>
<section id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this heading">¶</a></h2>
<p>1. If a function throws an exception while writing a complex type, then the output of the
row being written as well as the output of the next row are undefined. Hence, it’s recommended
to avoid throwing exceptions after writing has started for a complex output within the function.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">View and Writer Types</a><ul>
<li><a class="reference internal" href="#inputs-view-types">Inputs (View Types)</a></li>
<li><a class="reference internal" href="#outputs-writer-types">Outputs (Writer Types)</a></li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="aggregate-functions.html"
                          title="previous chapter">How to add an aggregate function?</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="lambda-functions.html"
                          title="next chapter">How to add a lambda function?</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/develop/view-and-writer-types.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="lambda-functions.html" title="How to add a lambda function?"
             >next</a> |</li>
        <li class="right" >
          <a href="aggregate-functions.html" title="How to add an aggregate function?"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" >Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">View and Writer Types</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright TBD.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.2.0.
    </div>
  </body>
</html>