
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>SIMD Usage in Velox &#8212; Velox  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory Management" href="memory.html" />
    <link rel="prev" title="What’s in the Task?" href="task.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="memory.html" title="Memory Management"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="task.html" title="What’s in the Task?"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" accesskey="U">Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">SIMD Usage in Velox</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="simd-usage-in-velox">
<h1>SIMD Usage in Velox<a class="headerlink" href="#simd-usage-in-velox" title="Permalink to this heading">¶</a></h1>
<p>SIMD uses special registers in CPU to operate on multiple primitive data
simultaneously.  In some basic cases compiler is able to translate a tight loop
into SIMD instructions for us, but often we need to call the SIMD intrinsics
explicitly.</p>
<p>There are several places in Velox where we use SIMD explicitly to get better
performance.  We use <a class="reference external" href="https://github.com/xtensor-stack/xsimd">xsimd</a> as a zero-cost abstraction over the intrinsics, to
address the portability issue.</p>
<section id="architectures">
<h2>Architectures<a class="headerlink" href="#architectures" title="Permalink to this heading">¶</a></h2>
<p>In Velox we support 2 families of CPU architectures regarding SIMD: X86 and ARM.
In X86 there are 3 generations of SIMD technologies: SSE, AVX, and AVX512.  For
ARM there are NEON and SVE.  Each architecture has its own size of registers, we
summarize the details below:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Architecture</p></th>
<th class="head"><p>Register Size (bits)</p></th>
<th class="head"><p>Used in Velox</p></th>
<th class="head"><p>CPU Family</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SSE</p></td>
<td><p>128</p></td>
<td><p>Yes</p></td>
<td><p>x86</p></td>
</tr>
<tr class="row-odd"><td><p>AVX</p></td>
<td><p>256</p></td>
<td><p>Yes</p></td>
<td><p>x86</p></td>
</tr>
<tr class="row-even"><td><p>AVX512</p></td>
<td><p>512</p></td>
<td><p>No</p></td>
<td><p>x86</p></td>
</tr>
<tr class="row-odd"><td><p>NEON</p></td>
<td><p>128</p></td>
<td><p>Yes</p></td>
<td><p>ARM</p></td>
</tr>
<tr class="row-even"><td><p>SVE</p></td>
<td><p>128 - 2048</p></td>
<td><p>No</p></td>
<td><p>ARM</p></td>
</tr>
</tbody>
</table>
</section>
<section id="xsimd-basics">
<h2>xsimd Basics<a class="headerlink" href="#xsimd-basics" title="Permalink to this heading">¶</a></h2>
<p>The data structure in <code class="docutils literal notranslate"><span class="pre">xsimd</span></code> to represent a SIMD register is <code class="docutils literal notranslate"><span class="pre">batch&lt;T,</span> <span class="pre">A&gt;</span></code>.
<code class="docutils literal notranslate"><span class="pre">T</span></code> stands for the element data type and <code class="docutils literal notranslate"><span class="pre">A</span></code> stands for the architecture.
For example <code class="docutils literal notranslate"><span class="pre">batch&lt;int32_t,</span> <span class="pre">avx2&gt;</span></code> represents a SIMD vector containing 32 bits
signed integers on AVX2.  This type has only 1 field called <code class="docutils literal notranslate"><span class="pre">data</span></code>, which is
the underlying SIMD register (e.g. for AVX it can be <code class="docutils literal notranslate"><span class="pre">__m256</span></code>, <code class="docutils literal notranslate"><span class="pre">__m256d</span></code>, or
<code class="docutils literal notranslate"><span class="pre">__m256i</span></code>).  This ensures the data structure can be optimized directly as the
register without any overhead during runtime.</p>
<p>When you compare 2 SIMD vectors (e.g. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>), there are 2 kinds of result
type, depending on the architecture.  For AVX512, the comparison result is kept
as a bit mask (1 bit per element, up to 64 bits) in a normal integer.  For all
other architectures, the result is kept in another SIMD register with the same
number of lanes as the operands, and each element in the result is set to
either -1 (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or 0 (<code class="docutils literal notranslate"><span class="pre">false</span></code>).  In <code class="docutils literal notranslate"><span class="pre">xsimd</span></code> these 2 types are unified
to one type: <code class="docutils literal notranslate"><span class="pre">batch_bool&lt;T,</span> <span class="pre">A&gt;</span></code>.  <code class="docutils literal notranslate"><span class="pre">T</span></code> is the element type of comparison
operands, and <code class="docutils literal notranslate"><span class="pre">A</span></code> is the architecture.</p>
<p><code class="docutils literal notranslate"><span class="pre">xsimd</span></code> provides some functions and operators to abstract the intrinsics on
different architectures, including basic arithmetics, comparisons, bitwise
operations, mathematical functions, loading or storing from memory.</p>
</section>
<section id="simd-utilities">
<h2>SIMD Utilities<a class="headerlink" href="#simd-utilities" title="Permalink to this heading">¶</a></h2>
<p>There are some intrinsics that are not yet abstracted by <code class="docutils literal notranslate"><span class="pre">xsimd</span></code>.  We added
the ones commonly used in Velox in <code class="docutils literal notranslate"><span class="pre">common/base/SimdUtil.h</span></code>.</p>
<section id="halfbatch">
<h3>HalfBatch<a class="headerlink" href="#halfbatch" title="Permalink to this heading">¶</a></h3>
<p>In <code class="docutils literal notranslate"><span class="pre">xsimd</span></code> the vector size is decided uniquely by the architecture <code class="docutils literal notranslate"><span class="pre">A</span></code>.  In
some cases we need a different size of vector though, for example in gather, if
the data type is 64 bits and index type is 32 bits, the vector for indices needs
to be the half size of the vector for data.  To accommodate such needs, we
define a type <code class="docutils literal notranslate"><span class="pre">HalfBatch&lt;T,</span> <span class="pre">A&gt;</span></code> to get the corresponding vector type.</p>
<p>In some cases when the default vector size is 128 bits, there is no
corresponding SIMD vector of 64 bits to be used as <code class="docutils literal notranslate"><span class="pre">HalfBatch</span></code>.  In such cases
we define and use a type <code class="docutils literal notranslate"><span class="pre">Batch64&lt;T&gt;</span></code>, with some methods and operators same as
<code class="docutils literal notranslate"><span class="pre">batch&lt;T,</span> <span class="pre">A&gt;</span></code>, so that we can use them interchangeably.</p>
</section>
<section id="gather">
<h3>Gather<a class="headerlink" href="#gather" title="Permalink to this heading">¶</a></h3>
<p>Gather is an operation to load a vector from non-contiguous memory.  In the
simplest form, given a <code class="docutils literal notranslate"><span class="pre">base</span></code> address and a list of <code class="docutils literal notranslate"><span class="pre">indices</span></code> (saved in a
SIMD vector), gather returns another vector containing all elements at</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">base</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">base</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">base</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>A variance of gather called <code class="docutils literal notranslate"><span class="pre">maskGather</span></code> takes an extra vector <code class="docutils literal notranslate"><span class="pre">src</span></code> and a
<code class="docutils literal notranslate"><span class="pre">batch_bool</span></code> mask, only loads the data from corresponding memory address if
<code class="docutils literal notranslate"><span class="pre">mask[i]</span></code> is set, otherwise uses the element in <code class="docutils literal notranslate"><span class="pre">src[i]</span></code>.  In other words,
the function returns <code class="docutils literal notranslate"><span class="pre">dst</span></code> where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
  <span class="n">dst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="k">else</span>
  <span class="n">dst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="bit-masks">
<h3>Bit Masks<a class="headerlink" href="#bit-masks" title="Permalink to this heading">¶</a></h3>
<p>As mentioned above, <code class="docutils literal notranslate"><span class="pre">batch_bool</span></code> is used to represent the result of a
comparison, and the underlying data can be either a bit mask or a SIMD vector.
To allow us manipulate this result, we provide some utilities to convert between
<code class="docutils literal notranslate"><span class="pre">batch_bool</span></code> and bit mask (<code class="docutils literal notranslate"><span class="pre">toBitMask</span></code> and <code class="docutils literal notranslate"><span class="pre">fromBitMask</span></code>).  Once you
convert it to bit mask, you can use the normal bit manipulating operations on
it.  We also provide utilities like <code class="docutils literal notranslate"><span class="pre">leadingMask</span></code> and <code class="docutils literal notranslate"><span class="pre">allSetBitMask</span></code> to
make it easier and faster to manipulate bits.</p>
</section>
<section id="filter">
<h3>Filter<a class="headerlink" href="#filter" title="Permalink to this heading">¶</a></h3>
<p>Another important function we have in <code class="docutils literal notranslate"><span class="pre">SimdUtil.h</span></code> is <code class="docutils literal notranslate"><span class="pre">filter</span></code>.  It takes a
SIMD vector <code class="docutils literal notranslate"><span class="pre">data</span></code> and a <code class="docutils literal notranslate"><span class="pre">bitMask</span></code>, then for each <code class="docutils literal notranslate"><span class="pre">i</span></code> where <code class="docutils literal notranslate"><span class="pre">bitMask[i]</span></code>
is set, we move the corresponding <code class="docutils literal notranslate"><span class="pre">data[i]</span></code> to front and return the result.
This behaves very similar to <code class="docutils literal notranslate"><span class="pre">std::partition</span></code>.  In other words, the function
returns <code class="docutils literal notranslate"><span class="pre">dst</span></code> where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">n</span>
  <span class="k">if</span> <span class="n">bitMask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">dst</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">n</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">bitMask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">dst</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="bmi-utilities">
<h2>BMI Utilities<a class="headerlink" href="#bmi-utilities" title="Permalink to this heading">¶</a></h2>
<p>In addition to SIMD abstraction and utilities, we also have some functions that
depend on BMI2 intrinsics.  We define the portable version of them in
<code class="docutils literal notranslate"><span class="pre">common/base/BitUtil.h</span></code>.  These functions include <code class="docutils literal notranslate"><span class="pre">extractBits</span></code> and
<code class="docutils literal notranslate"><span class="pre">rotateLeft</span></code>.  They are relatively simple and standalone comparing to SIMD,
and you can refer the documentation in the file for their usage.</p>
</section>
<section id="use-cases">
<h2>Use Cases<a class="headerlink" href="#use-cases" title="Permalink to this heading">¶</a></h2>
<section id="hash-table">
<h3>Hash Table<a class="headerlink" href="#hash-table" title="Permalink to this heading">¶</a></h3>
<p>In <code class="docutils literal notranslate"><span class="pre">BigintValuesUsingHashTable::testValues</span></code> we use SIMD to check whether
multiple values are in the hash table at same time.  In the hash table we use a
special empty marker to indicate the value is missing.  The process is
following:</p>
<ol class="arabic simple">
<li><p>If all values are out of range, we can return all false.</p></li>
<li><p>If empty marker has been inserted into the hash table, fall back to check the
values one by one.</p></li>
<li><p>Hash all valid values using SIMD multiplication and modulo, and then get the
corresponding states in hash table using <code class="docutils literal notranslate"><span class="pre">maskGather</span></code>.</p></li>
<li><p>If the state is empty marker, the value is missing; if the state is equal to
value, the value is found.  Otherwise we have an hash collision and need to
look at next positions in hash table.  If no collision is happening, we can
return the result right away.</p></li>
<li><p>For each value that has collision, we use SIMD to advance multiple positions
at once, until we find either value match or empty mark.</p></li>
</ol>
</section>
<section id="filtering">
<h3>Filtering<a class="headerlink" href="#filtering" title="Permalink to this heading">¶</a></h3>
<p>A typical use case for filtering values using SIMD is in <code class="docutils literal notranslate"><span class="pre">processFixedFilter</span></code>
from <code class="docutils literal notranslate"><span class="pre">dwio/dwrf/common/DecoderUtil.h</span></code>.  This function evaluates the filter on
a batch of values, and stores the passed row numbers from this batch to
<code class="docutils literal notranslate"><span class="pre">filterHits</span></code>, and the passed values to <code class="docutils literal notranslate"><span class="pre">rawValues</span></code>.</p>
<p>The filtering on values is done using <code class="docutils literal notranslate"><span class="pre">Filter::testValues</span></code>, the result is
stored in a bit mask.  We then pass the bit mask to <code class="docutils literal notranslate"><span class="pre">simd::filter</span></code> to store
indices and values.  Finally we increase <code class="docutils literal notranslate"><span class="pre">numValues</span></code> with the popcount of bit
mask.</p>
<p>Note when the data type is 16 bits long, we need to do the process in 2 batches
(<code class="docutils literal notranslate"><span class="pre">loadIndices(0)</span></code> and <code class="docutils literal notranslate"><span class="pre">loadIndices(1)</span></code>), because the indices are 32 bits
long and one SIME vector is not large enough to contain all the indices needed.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">SIMD Usage in Velox</a><ul>
<li><a class="reference internal" href="#architectures">Architectures</a></li>
<li><a class="reference internal" href="#xsimd-basics">xsimd Basics</a></li>
<li><a class="reference internal" href="#simd-utilities">SIMD Utilities</a><ul>
<li><a class="reference internal" href="#halfbatch">HalfBatch</a></li>
<li><a class="reference internal" href="#gather">Gather</a></li>
<li><a class="reference internal" href="#bit-masks">Bit Masks</a></li>
<li><a class="reference internal" href="#filter">Filter</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bmi-utilities">BMI Utilities</a></li>
<li><a class="reference internal" href="#use-cases">Use Cases</a><ul>
<li><a class="reference internal" href="#hash-table">Hash Table</a></li>
<li><a class="reference internal" href="#filtering">Filtering</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="task.html"
                          title="previous chapter">What’s in the Task?</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="memory.html"
                          title="next chapter">Memory Management</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/develop/simd.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="memory.html" title="Memory Management"
             >next</a> |</li>
        <li class="right" >
          <a href="task.html" title="What’s in the Task?"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" >Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">SIMD Usage in Velox</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright TBD.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.2.0.
    </div>
  </body>
</html>