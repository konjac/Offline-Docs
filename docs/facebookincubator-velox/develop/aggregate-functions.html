
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>How to add an aggregate function? &#8212; Velox  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="View and Writer Types" href="view-and-writer-types.html" />
    <link rel="prev" title="How to add a scalar function?" href="scalar-functions.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="view-and-writer-types.html" title="View and Writer Types"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="scalar-functions.html" title="How to add a scalar function?"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" accesskey="U">Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to add an aggregate function?</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="how-to-add-an-aggregate-function">
<h1>How to add an aggregate function?<a class="headerlink" href="#how-to-add-an-aggregate-function" title="Permalink to this heading">¶</a></h1>
<p>Aggregate functions are calculated by the HashAggregation operator.
There can be one or more aggregate functions in a single operator.
Here are some examples.</p>
<p>Global aggregation (no grouping keys), single aggregate “count”.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t</span>
</pre></div>
</div>
<p>Global aggregation, two aggregates: “count” and “sum”:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t</span>
</pre></div>
</div>
<p>Aggregation with three aggregates: “count” and two “sum”s.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="k">c</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>Aggregation with just one aggregate - “min” - and two grouping keys.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">min</span><span class="p">(</span><span class="k">c</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
<p>Typically, aggregations are calculated in two steps: partial aggregation
and final aggregation.</p>
<p>Partial aggregation takes raw data and produces intermediate results. Final
aggregation takes intermediate results and produces the final result. There
are also single and intermediate aggregations that are used in some cases.
Single aggregation is used when data is already partitioned on the grouping
keys and therefore no shuffle is necessary. Intermediate aggregations are used
to combine the results of partial aggregations computed in multiple threads in
parallel to reduce the amount of data sent to the final aggregation stage.</p>
<p>The four types, steps, of aggregation are distinguished solely by the types of
input and output.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Step</p></th>
<th class="head"><p>Input</p></th>
<th class="head"><p>Output</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Partial</strong></p></td>
<td><p>Raw Data</p></td>
<td><p>Intermediate Results</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Final</strong></p></td>
<td><p>Intermediate Results</p></td>
<td><p>Final Results</p></td>
</tr>
<tr class="row-even"><td><p><strong>Single</strong></p></td>
<td><p>Raw Data</p></td>
<td><p>Final Results</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Intermediate</strong></p></td>
<td><p>Intermediate Results</p></td>
<td><p>Intermediate Results</p></td>
</tr>
</tbody>
</table>
<p>In some cases, the calculations performed by partial and final aggregations are
the same. This is the case for the <a class="reference internal" href="../functions/presto/aggregate.html#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a> and <a class="reference internal" href="../functions/presto/aggregate.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>
aggregates. In most cases they are different. For example, partial <a class="reference internal" href="../functions/presto/aggregate.html#count" title="count"><code class="xref py py-func docutils literal notranslate"><span class="pre">count()</span></code></a>
aggregate counts incoming values and final <a class="reference internal" href="../functions/presto/aggregate.html#count" title="count"><code class="xref py py-func docutils literal notranslate"><span class="pre">count()</span></code></a> aggregate sums up partial
counts to produce a total.</p>
<p>The signature of an aggregate function consists of the type of the raw input data,
the type of the intermediate result and the type of the final result.</p>
<p>Aggregate functions can also be used in a window operator. Here is an example of
computing running total that uses <a class="reference internal" href="../functions/presto/aggregate.html#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a> aggregate function in a window operator.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="n">PARTITION</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="k">DESC</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t</span>
</pre></div>
</div>
<section id="memory-layout">
<h2>Memory Layout<a class="headerlink" href="#memory-layout" title="Permalink to this heading">¶</a></h2>
<p>HashAggregation operator stores data in rows. Each row corresponds to a unique combination of grouping key values. Global aggregations store data in a single row.</p>
<p>Aggregate functions can be classified by the type of their accumulators into three groups:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Fixed width accumulators:</dt><dd><ul>
<li><p><a class="reference internal" href="../functions/presto/aggregate.html#count" title="count"><code class="xref py py-func docutils literal notranslate"><span class="pre">count()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#avg" title="avg"><code class="xref py py-func docutils literal notranslate"><span class="pre">avg()</span></code></a></p></li>
<li><p><a class="reference internal" href="../functions/presto/aggregate.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#arbitrary" title="arbitrary"><code class="xref py py-func docutils literal notranslate"><span class="pre">arbitrary()</span></code></a> (for fixed-width types)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Variable width accumulators with append-only semantics:</dt><dd><ul>
<li><p><a class="reference internal" href="../functions/presto/aggregate.html#array_agg" title="array_agg"><code class="xref py py-func docutils literal notranslate"><span class="pre">array_agg()</span></code></a></p></li>
<li><p><a class="reference internal" href="../functions/presto/aggregate.html#map_agg" title="map_agg"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_agg()</span></code></a></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Variable width accumulators which can be modified in any way, not just appended to.</dt><dd><ul>
<li><p><a class="reference internal" href="../functions/presto/aggregate.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> (for strings)</p></li>
<li><p><a class="reference internal" href="../functions/presto/aggregate.html#arbitrary" title="arbitrary"><code class="xref py py-func docutils literal notranslate"><span class="pre">arbitrary()</span></code></a> (for variable-width types)</p></li>
<li><p><a class="reference internal" href="../functions/presto/aggregate.html#approx_percentile" title="approx_percentile"><code class="xref py py-func docutils literal notranslate"><span class="pre">approx_percentile()</span></code></a></p></li>
<li><p><a class="reference internal" href="../functions/presto/aggregate.html#approx_distinct" title="approx_distinct"><code class="xref py py-func docutils literal notranslate"><span class="pre">approx_distinct()</span></code></a></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Fixed-width part of the accumulator is stored in the row. Variable-width
part (if exists) is allocated using <a class="reference internal" href="arena.html"><span class="doc">HashStringAllocator</span></a> and a pointer is
stored in the fixed-width part.</p>
<p>A row is a contiguous byte buffer.  If any of the accumulators has alignment
requirement, the row beginning and accumulator address will be aligned
accordingly.  Data is stored in the following order:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>Null flags (1 bit per item) for</dt><dd><ol class="arabic simple">
<li><p>Keys (only if nullable)</p></li>
<li><p>Accumulators</p></li>
</ol>
</dd>
</dl>
</li>
<li><p>Free flag (1 bit)</p></li>
<li><p>Keys</p></li>
<li><p>Padding for alignment</p></li>
<li><p>Accumulators, fixed-width part only</p></li>
<li><p>Variable size (32 bit)</p></li>
<li><p>Padding for alignment</p></li>
</ol>
<a class="reference internal image-reference" href="../_images/aggregation-layout.png"><img alt="../_images/aggregation-layout.png" src="../_images/aggregation-layout.png" style="width: 600px;" /></a>
<p>To add an aggregate function, there are two options: implementing it as a
simple function or as a vector function. The simple-function interface allows
the author to write methods that process input data one row at a time and not
handle input vector encodings themselves. However, the simple-function
interface currently has certain limitations, such as not allowing for advanced
performance optimization on constant inputs. Aggregation functions that
require such functionalities can be implemented through the vector-function
interface. With the vector-function interface, the author writes methods that
process one vector at a time and handles input vector encodings by themselves.</p>
<ul class="simple">
<li><dl class="simple">
<dt>Prepare:</dt><dd><ul>
<li><p>Figure out what are the input, intermediate and final types.</p></li>
<li><p>Figure out what are partial and final calculations.</p></li>
<li><p>Design the accumulator. Make sure the same accumulator can accept both raw
inputs and intermediate results.</p></li>
<li><p>If implementing a simple function, create a class for the function according
to instructions below; If implementing a vector function,
create a new class that extends velox::exec::Aggregate base class
(see velox/exec/Aggregate.h) and implement virtual methods.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Register the new function using exec::registerAggregateFunction(…).</p></li>
<li><p>Add tests.</p></li>
<li><p>Write documentation.</p></li>
</ul>
</section>
<section id="simple-function-interface">
<h2>Simple Function Interface<a class="headerlink" href="#simple-function-interface" title="Permalink to this heading">¶</a></h2>
<p>This section describes the main concepts and the simple interface of
aggregation functions. Examples of aggregation functions implemented through
the simple-function interface can be found at velox/exec/tests/SimpleAverageAggregate.cpp
and velox/exec/tests/SimpleArrayAggAggregate.cpp.</p>
<p>A simple aggregation function is implemented as a class as the following.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// array_agg(T) -&gt; array(T) -&gt; array(T)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ArrayAggAggregate</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Type(s) of input vector(s) wrapped in Row.</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">InputType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Row</span><span class="o">&lt;</span><span class="n">Generic</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">IntermediateType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Generic</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">OutputType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Generic</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Optional. Default is true.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">default_null_behavior_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Optional.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">toIntermediate</span><span class="p">(</span>
<span class="w">    </span><span class="n">exec</span><span class="o">::</span><span class="n">out_type</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Generic</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;&gt;&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span>
<span class="w">    </span><span class="n">exec</span><span class="o">::</span><span class="n">optional_arg_type</span><span class="o">&lt;</span><span class="n">Generic</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">in</span><span class="p">);</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">AccumulatorType</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The author declares the function’s input type, intermediate type, and output
type in the simple aggregation function class. The input type must be the
function’s argument type(s) wrapped in a Row&lt;&gt; even if the function only takes
one argument. This is needed for the SimpleAggregateAdapter to parse input
types for arbitrary aggregation functions properly.</p>
<p>The author can define an optional flag <cite>default_null_behavior_</cite> indicating
whether the aggregation function has default-null behavior. This flag is true
by default. Next, the class can have an optional method <cite>toIntermediate()</cite>
that converts the aggregation function’s raw input directly to its intermediate
states. Finally, the author must define a struct named <cite>AccumulatorType</cite> in
the aggregation function class. We explain each part in more details below.</p>
<section id="default-null-behavior">
<h3>Default-Null Behavior<a class="headerlink" href="#default-null-behavior" title="Permalink to this heading">¶</a></h3>
<p>When adding raw inputs or intermediate states to accumulators, aggregation
functions of default-null behavior ignore the input values that are nulls. For
raw inputs that consist of multiple columns, an entire row is ignored if at
least one column is null at this row. Below is an example.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">values</span><span class="w"> </span><span class="p">(</span><span class="k">cast</span><span class="p">(</span><span class="k">NULL</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">bigint</span><span class="p">),</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">);</span><span class="w"> </span><span class="c1">-- NULL</span>
</pre></div>
</div>
<p>When generating intermediate or final output results from accumulators,
aggregation functions of default-null behavior produce nulls for groups of no
input row or only null rows. Another example is given below.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">values</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">)</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">40</span><span class="p">;</span><span class="w"> </span><span class="c1">-- NULL</span>
</pre></div>
</div>
<p>Most aggregation functions have default-null behavior. An example is in
SimpleAverageAggregate.cpp. On the other hand, SimpleArrayAggAggregate.cpp has
an example of non-default-null behavior.</p>
<p>This flag affects the C++ function signatures of <cite>toIntermediate()</cite> and methods
in the <cite>AccumulatorType</cite> struct.</p>
</section>
<section id="tointermediate">
<h3>toIntermediate<a class="headerlink" href="#tointermediate" title="Permalink to this heading">¶</a></h3>
<p>The author can optionally define a static method <cite>toIntermediate()</cite> that
converts a raw input to an intermediate state. If defined, this function is
used in query plans that abandon the partial aggregation step. If the aggregaiton function has
default-null behavior, the toIntermediate() function has an out-parameter
of the type <cite>exec::out_type&lt;IntermediateType&gt;&amp;</cite> followed by in-parameters of
the type <cite>exec::arg_type&lt;T&gt;</cite> for each <cite>T</cite> wrapped inside InputType . If the
aggregation function has non-default null behavior, the in-parameters of
toIntermediate() are of the type <cite>exec::optional_arg_type&lt;T&gt;</cite> instead.</p>
<p>When <cite>T</cite> is a primitive type except Varchar and Varbinary, <cite>exec::arg_type&lt;T&gt;</cite>
is simply <cite>T</cite> itself and <cite>exec::out_type&lt;T&gt;</cite> is <cite>T&amp;</cite>. <cite>exec::optional_arg_type&lt;T&gt;</cite>
is <cite>std::optional&lt;T&gt;</cite>.</p>
<p>When <cite>T</cite> is Varchar, Varbinary, or a complex type, <cite>exec::arg_type&lt;T&gt;</cite>,
<cite>exec::optional_arg_type&lt;T&gt;</cite>, and <cite>exec::out_type&lt;T&gt;</cite> are the corresponding
view and writer types of <cite>T</cite>. A datailed explanaion can be found in <a class="reference internal" href="view-and-writer-types.html"><span class="doc">View and Writer Types</span></a>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Default-Null Behavior</p></th>
<th class="head"><p>Non-Default-Null Behavior</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="simple">
<dt>static bool SimpleAverageAggregate::toIntermediate(</dt><dd><p>exec::out_type&lt;Row&lt;double, int64_t&gt;&gt;&amp; out,
exec::arg_type&lt;T&gt; in);</p>
</dd>
</dl>
</td>
<td><dl class="simple">
<dt>static bool SimpleArrayAggAggregate::toIntermediate(</dt><dd><p>exec::out_type&lt;Array&lt;Generic&lt;T1&gt;&gt;&gt;&amp; out,
exec::optional_arg_type&lt;Generic&lt;T1&gt;&gt; in);</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</section>
<section id="accumulatortype-of-default-null-behavior">
<h3>AccumulatorType of Default-Null Behavior<a class="headerlink" href="#accumulatortype-of-default-null-behavior" title="Permalink to this heading">¶</a></h3>
<p>For aggregaiton functions of default-null behavior, the author defines an
<cite>AccumulatorType</cite> struct as follows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">AccumulatorType</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Author defines data members</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="c1">// Optional. Default is true.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_fixed_size_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Optional. Default is false.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_external_memory_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Optional. Default is false.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_aligned_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">AccumulatorType</span><span class="p">(</span><span class="n">HashStringAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">allocator</span><span class="p">);</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">addInput</span><span class="p">(</span><span class="n">HashStringAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">allocator</span><span class="p">,</span><span class="w"> </span><span class="n">exec</span><span class="o">::</span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">value1</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span>
<span class="w">      </span><span class="n">HashStringAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">allocator</span><span class="p">,</span>
<span class="w">      </span><span class="n">exec</span><span class="o">::</span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">IntermediateType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">writeIntermediateResult</span><span class="p">(</span><span class="n">exec</span><span class="o">::</span><span class="n">out_type</span><span class="o">&lt;</span><span class="n">IntermediateType</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">);</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">writeFinalResult</span><span class="p">(</span><span class="n">exec</span><span class="o">::</span><span class="n">out_type</span><span class="o">&lt;</span><span class="n">OutputType</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Optional. Called during destruction.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">destroy</span><span class="p">(</span><span class="n">HashStringAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">allocator</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The author defines an optional flag <cite>is_fixed_size_</cite> indicating whether the
every accumulator takes fixed amount of memory. This flag is true by default.
Next, the author defines another optional flag <cite>use_external_memory_</cite>
indicating whether the accumulator uses memory that is not tracked by Velox.
This flag is false by default. Then, the author can define an optional flag
<cite>is_aligned_</cite> indicating whether the accumulator requires aligned
access. This flag is false by default.</p>
<p>The author defines a constructor that takes a single argument of
<cite>HashStringAllocator*</cite>. This constructor is called before aggregation starts to
initialize all accumulators.</p>
<p>The author can also optionally define a <cite>destroy</cite> function that is called when
<em>this</em> accumulator object is destructed.</p>
<p>Notice that <cite>writeIntermediateResult</cite> and <cite>writeFinalResult</cite> are expected to not
modify contents in the accumulator.</p>
<section id="addinput">
<h4>addInput<a class="headerlink" href="#addinput" title="Permalink to this heading">¶</a></h4>
<p>This method adds raw input values to <em>this</em> accumulator. It receives a
<cite>HashStringAllocator*</cite> followed by <cite>exec::arg_type&lt;T1&gt;</cite>-typed values, one for
each argument type <cite>Ti</cite> wrapped in InputType.</p>
<p>With default-null behavior, raw-input rows where at least one column is null are
ignored before <cite>addInput</cite> is called. After <cite>addInput</cite> is called, <em>this</em>
accumulator is assumed to be non-null.</p>
</section>
<section id="combine">
<h4>combine<a class="headerlink" href="#combine" title="Permalink to this heading">¶</a></h4>
<p>This method adds an input intermediate state to <em>this</em> accumulator. It receives
a <cite>HashStringAllocator*</cite> and one <cite>exec::arg_type&lt;IntermediateType&gt;</cite> value. With
default-null behavior, nulls among the input intermediate states are ignored
before <cite>combine</cite> is called. After <cite>combine</cite> is called, <em>this</em>  accumulator is
assumed to be non-null.</p>
</section>
<section id="writeintermediateresult">
<h4>writeIntermediateResult<a class="headerlink" href="#writeintermediateresult" title="Permalink to this heading">¶</a></h4>
<p>This method writes <em>this</em> accumulator out to an intermediate state vector. It
has an out-parameter of the type <cite>exec::out_type&lt;IntermediateType&gt;&amp;</cite>. This
method returns true if it writes a non-null value to <cite>out</cite>, or returns false
meaning a null should be written to the intermediate state vector. Accumulators
that are nulls (i.e., no value has been added to them) automatically become
nulls in the intermediate state vector without <cite>writeIntermediateResult</cite> being
called.</p>
</section>
<section id="writefinalresult">
<h4>writeFinalResult<a class="headerlink" href="#writefinalresult" title="Permalink to this heading">¶</a></h4>
<p>This method writes <em>this</em> accumulator out to a final result vector. It
has an out-parameter of the type <cite>exec::out_type&lt;OutputType&gt;&amp;</cite>. This
method returns true if it writes a non-null value to <cite>out</cite>, or returns false
meaning a null should be written to the final result vector. Accumulators
that are nulls (i.e., no value has been added to them) automatically become
nulls in the final result vector without <cite>writeFinalResult</cite> being called.</p>
</section>
</section>
<section id="accumulatortype-of-non-default-null-behavior">
<h3>AccumulatorType of Non-Default-Null Behavior<a class="headerlink" href="#accumulatortype-of-non-default-null-behavior" title="Permalink to this heading">¶</a></h3>
<p>For aggregaiton functions of non-default-null behavior, the author defines an
<cite>AccumulatorType</cite> struct as follows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">AccumulatorType</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Author defines data members</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="c1">// Optional. Default is true.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_fixed_size_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Optional. Default is false.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_external_memory_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Optional. Default is false.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_aligned_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">AccumulatorType</span><span class="p">(</span><span class="n">HashStringAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">allocator</span><span class="p">);</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">addInput</span><span class="p">(</span><span class="n">HashStringAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">allocator</span><span class="p">,</span><span class="w"> </span><span class="n">exec</span><span class="o">::</span><span class="n">optional_arg_type</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">value1</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span>
<span class="w">      </span><span class="n">HashStringAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">allocator</span><span class="p">,</span>
<span class="w">      </span><span class="n">exec</span><span class="o">::</span><span class="n">optional_arg_type</span><span class="o">&lt;</span><span class="n">IntermediateType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">writeIntermediateResult</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">nonNullGroup</span><span class="p">,</span><span class="w"> </span><span class="n">exec</span><span class="o">::</span><span class="n">out_type</span><span class="o">&lt;</span><span class="n">IntermediateType</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">);</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">writeFinalResult</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">nonNullGroup</span><span class="p">,</span><span class="w"> </span><span class="n">exec</span><span class="o">::</span><span class="n">out_type</span><span class="o">&lt;</span><span class="n">OutputType</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Optional.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">destroy</span><span class="p">(</span><span class="n">HashStringAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">allocator</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The definition of <cite>is_fixed_size_</cite>, <cite>use_external_memory_</cite>,
<cite>is_aligned_</cite>, the constructor, and the <cite>destroy</cite> method are exactly
the same as those for default-null behavior.</p>
<p>On the other hand, the C++ function signatures of <cite>addInput</cite>, <cite>combine</cite>,
<cite>writeIntermediateResult</cite>, and <cite>writeFinalResult</cite> are different.</p>
<p>Same as the case for default-null behavior, <cite>writeIntermediateResult</cite> and
<cite>writeFinalResult</cite> are expected to not modify contents in the accumulator.</p>
<section id="id1">
<h4>addInput<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h4>
<p>This method receives a <cite>HashStringAllocator*</cite> followed by
<cite>exec::optional_arg_type&lt;T1&gt;</cite> values, one for each argument type <cite>Ti</cite> wrapped
in InputType.</p>
<p>This method is called on all raw-input rows even if some columns may be null.
It returns a boolean meaning whether <em>this</em> accumulator is non-null after the
call. All accumulators are initialized to <em>null</em> before aggregation starts. An
accumulator that is originally null can be turned to non-null. But an
accumulator that’s already non-null remains non-null regardless of the return
value of <cite>addInput</cite>.</p>
</section>
<section id="id2">
<h4>combine<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h4>
<p>This method receives a <cite>HashStringAllocator*</cite> and an
<cite>exec::optional_arg_type&lt;IntermediateType&gt;</cite> value. This method is called on
all intermediate states even if some are nulls. Same as <cite>addInput</cite>, this method
returns a boolean meaning whether <em>this</em> accumulator is non-null after the call.</p>
</section>
<section id="id3">
<h4>writeIntermediateResult<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h4>
<p>This method has an out-parameter of the type <cite>exec::out_type&lt;IntermediateType&gt;&amp;</cite>
and a boolean flag <cite>nonNullGroup</cite> indicating whether <em>this</em> accumulator is
non-null. This method returns true if it writes a non-null value to <cite>out</cite>, or
return false meaning a null should be written to the intermediate state vector.</p>
</section>
<section id="id4">
<h4>writeFinalResult<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h4>
<p>This method writes <em>this</em> accumulator out to a final result vector. It has an
out-parameter of the type <cite>exec::out_type&lt;OutputType&gt;&amp;</cite> and a boolean flag
<cite>nonNullGroup</cite> indicating whether <em>this</em> accumulator is non-null. This method
returns true if it writes a non-null value to <cite>out</cite>, or return false meaning a
null should be written to the final result vector.</p>
</section>
</section>
<section id="limitations">
<h3>Limitations<a class="headerlink" href="#limitations" title="Permalink to this heading">¶</a></h3>
<p>The simple aggregation function interface currently has three limitations.</p>
<ol class="arabic simple">
<li><p>All values read or written by the aggrgeaiton function must be part of the
accumulators. This means that there cannot be function-level states kept
outside of accumulators.</p></li>
<li><p>Optimizations on constant inputs is not supported. I.e., constant input
arguments are processed once per row in the same way as non-constant inputs.</p></li>
<li><p>Aggregation pushdown to table scan is not supported yet. We’re planning to
add this support.</p></li>
</ol>
</section>
</section>
<section id="vector-function-interface">
<h2>Vector Function Interface<a class="headerlink" href="#vector-function-interface" title="Permalink to this heading">¶</a></h2>
<p>Aggregation functions that cannot use the simple-function interface can be written as vector funcitons.</p>
<section id="accumulator-size">
<h3>Accumulator size<a class="headerlink" href="#accumulator-size" title="Permalink to this heading">¶</a></h3>
<p>The implementation of the velox::exec::Aggregate interface can start with <em>accumulatorFixedWidthSize()</em> method.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Returns the fixed number of bytes the accumulator takes on a group</span>
<span class="c1">// row. Variable width accumulators will reference the variable</span>
<span class="c1">// width part of the state from the fixed part.</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="nf">accumulatorFixedWidthSize</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>If accumulator requires specific alignment you need to implement <em>accumulatorAlignmentSize()</em> method.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Returns the alignment size of the accumulator.  Some types such as</span>
<span class="c1">/// int128_t require aligned access.  This value must be a power of 2.</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="nf">accumulatorAlignmentSize</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The HashAggregation operator uses these methods during initialization to calculate the total size
of the row and figure out offsets at which different aggregates will be storing their data. The
operator then calls velox::exec::Aggregate::setOffsets method for each aggregate to specify the
location of the accumulator.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Sets the offset and null indicator position of &#39;this&#39;.</span>
<span class="c1">// @param offset Offset in bytes from the start of the row of the accumulator</span>
<span class="c1">// @param nullByte Offset in bytes from the start of the row of the null flag</span>
<span class="c1">// @param nullMask The specific bit in the nullByte that stores the null flag</span>
<span class="c1">// @param initializedByte Offset in bytes from the start of the row of the</span>
<span class="c1">// initialized flag</span>
<span class="c1">// @param initializedMask The specific bit in the initializedByte that stores</span>
<span class="c1">// the initialized flag</span>
<span class="c1">// @param rowSizeOffset The offset of a uint32_t row size from the start of</span>
<span class="c1">// the row. Only applies to accumulators that store variable size data out of</span>
<span class="c1">// line. Fixed length accumulators do not use this. 0 if the row does not have</span>
<span class="c1">// a size field.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">setOffsets</span><span class="p">(</span>
<span class="w">  </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span>
<span class="w">  </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">nullByte</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">nullMask</span><span class="p">,</span>
<span class="w">  </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">initializedByte</span><span class="p">,</span>
<span class="w">  </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">initializedMask</span><span class="p">,</span>
<span class="w">  </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">rowSizeOffset</span><span class="p">)</span>
</pre></div>
</div>
<p>The base class implements the setOffsets method by storing the offsets in member variables.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Byte position of null flag in group row.</span>
<span class="kt">int32_t</span><span class="w"> </span><span class="n">nullByte_</span><span class="p">;</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">nullMask_</span><span class="p">;</span>
<span class="c1">// Byte position of the initialized flag in group row.</span>
<span class="kt">int32_t</span><span class="w"> </span><span class="n">initializedByte_</span><span class="p">;</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">initializedMask_</span><span class="p">;</span>
<span class="c1">// Offset of fixed length accumulator state in group row.</span>
<span class="kt">int32_t</span><span class="w"> </span><span class="n">offset_</span><span class="p">;</span>

<span class="c1">// Offset of uint32_t row byte size of row. 0 if there are no</span>
<span class="c1">// variable width fields or accumulators on the row.  The size is</span>
<span class="c1">// capped at 4G and will stay at 4G and not wrap around if growing</span>
<span class="c1">// past this. This serves to track the batch size when extracting</span>
<span class="c1">// rows. A size in excess of 4G would finish the batch in any case,</span>
<span class="c1">// so larger values need not be represented.</span>
<span class="kt">int32_t</span><span class="w"> </span><span class="n">rowSizeOffset_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Typically, an aggregate function doesn’t use the offsets directly. Instead, it uses helper methods from the base class.</p>
<p>To access the accumulator:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">group</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">group</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To manipulate the null flags:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">isNull</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">group</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="c1">// Sets null flag for all specified groups to true.</span>
<span class="c1">// For any given group, this method can be called at most once.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setAllNulls</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span><span class="w"> </span><span class="n">folly</span><span class="o">::</span><span class="n">Range</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">vector_size_t</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">indices</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">clearNull</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">group</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="Permalink to this heading">¶</a></h3>
<p>Once you have accumulatorFixedWidthSize(), the next method to implement is initializeNewGroupsInternal().</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Initializes null flags and accumulators for newly encountered groups.</span>
<span class="c1">// @param groups Pointers to the start of the new group rows.</span>
<span class="c1">// @param indices Indices into &#39;groups&#39; of the new entries.</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">initializeNewGroupsInternal</span><span class="p">(</span>
<span class="w">    </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span>
<span class="w">    </span><span class="n">folly</span><span class="o">::</span><span class="n">Range</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">vector_size_t</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">indices</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This method is called by the HashAggregation operator every time it encounters new combinations of the grouping keys. This method should initialize the accumulators for the new groups. For example, partial “count” and “sum” aggregates would set the accumulators to zero. Many aggregate functions would set null flags to true by calling the exec::Aggregate::setAllNulls(groups, indices) helper method.</p>
</section>
<section id="groupby-aggregation">
<h3>GroupBy aggregation<a class="headerlink" href="#groupby-aggregation" title="Permalink to this heading">¶</a></h3>
<p>At this point you have accumulatorFixedWidthSize() and initializeNewGroupsInternal() methods implemented. Now, we can proceed to implementing the end-to-end group-by aggregation. We need the following pieces:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Logic for adding raw input to the accumulator:</dt><dd><ul>
<li><p>addRawInput() method.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Logic for producing intermediate results from the accumulator:</dt><dd><ul>
<li><p>extractAccumulators() method.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Logic for adding intermediate results to the accumulator:</dt><dd><ul>
<li><p>addIntermediateResults() method.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Logic for producing final results from the accumulator:</dt><dd><ul>
<li><p>extractValues() method.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Logic for adding previously spilled data back to the accumulator:</dt><dd><ul>
<li><p>addSingleGroupIntermediateResults() method.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Optional logic for converting raw inputs into intermediate results:</dt><dd><ul>
<li><p>supportsToIntermediate() and toIntermediate() methods.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Some methods are only used in a subset of aggregation workflows. The following
table shows which methods are used in which workflows.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28.6%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Partial</p></th>
<th class="head"><p>Final</p></th>
<th class="head"><p>Single</p></th>
<th class="head"><p>Intermediate</p></th>
<th class="head"><p>Streaming</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>addRawInput</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>extractAccumulators</p></td>
<td><p>Y</p></td>
<td><p>Y (used for spilling)</p></td>
<td><p>Y (used for spilling)</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>addIntermediateResults</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>extractValues</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>addSingleGroupIntermediateResults</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-odd"><td><p>toIntermediate</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
</tr>
</tbody>
</table>
<p>We start with the addRawInput() method which receives raw input vectors and adds the data to accumulators.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Updates the accumulator in &#39;groups&#39; with the values in &#39;args&#39;.</span>
<span class="c1">// @param groups Pointers to the start of the group rows. These are aligned</span>
<span class="c1">// with the &#39;args&#39;, e.g. data in the i-th row of the &#39;args&#39; goes to the i-th group.</span>
<span class="c1">// The groups may repeat if different rows go into the same group.</span>
<span class="c1">// @param rows Rows of the &#39;args&#39; to add to the accumulators. These may not be</span>
<span class="c1">// contiguous if the aggregation is configured to drop null grouping keys.</span>
<span class="c1">// This would be the case when aggregation is followed by the join on the</span>
<span class="c1">// grouping keys.</span>
<span class="c1">// @param args Data to add to the accumulators.</span>
<span class="c1">// @param mayPushdown True if aggregation can be pushdown down via LazyVector.</span>
<span class="c1">// The pushdown can happen only if this flag is true and &#39;args&#39; is a single</span>
<span class="c1">// LazyVector.</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">addRawInput</span><span class="p">(</span>
<span class="w">    </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SelectivityVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VectorPtr</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">,</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">mayPushdown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>addRawInput() method would use DecodedVector’s to decode the input data. Then, loop over rows to update the accumulators. It is a good practice to define a member variable of type DecodedVector for each input vector. This allows for reusing the memory needed to decode the inputs between batches of input.</p>
<p>After implementing the addRawInput() method, we proceed to adding logic for extracting intermediate results.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Extracts partial results (used for partial and intermediate aggregations).</span>
<span class="c1">// This method is expected to not modify contents in accumulators.</span>
<span class="c1">// @param groups Pointers to the start of the group rows.</span>
<span class="c1">// @param numGroups Number of groups to extract results from.</span>
<span class="c1">// @param result The result vector to store the results in.</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">extractAccumulators</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">numGroups</span><span class="p">,</span><span class="w"> </span><span class="n">VectorPtr</span><span class="o">*</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Next, we implement the addIntermediateResults() method that receives intermediate results and updates accumulators.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">addIntermediateResults</span><span class="p">(</span>
<span class="w">    </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SelectivityVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VectorPtr</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">,</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">mayPushdown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Next, we implement the extractValues() method that extracts final results from the accumulators.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Extracts final results (used for final and single aggregations). This method</span>
<span class="c1">// is expected to not modify contents in accumulators.</span>
<span class="c1">// @param groups Pointers to the start of the group rows.</span>
<span class="c1">// @param numGroups Number of groups to extract results from.</span>
<span class="c1">// @param result The result vector to store the results in.</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">extractValues</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">numGroups</span><span class="p">,</span><span class="w"> </span><span class="n">VectorPtr</span><span class="o">*</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Finally, we implement the addSingleGroupIntermediateResults() method that is used to add previously spilled data back to the accumulator.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Updates the single final accumulator from intermediate results for global</span>
<span class="c1">// aggregation.</span>
<span class="c1">// @param group Pointer to the start of the group row.</span>
<span class="c1">// @param rows Rows of the &#39;args&#39; to add to the accumulators. These may not</span>
<span class="c1">// be contiguous if the aggregation has mask. &#39;rows&#39; is guaranteed to have at</span>
<span class="c1">// least one active row.</span>
<span class="c1">// @param args Intermediate results produced by extractAccumulators().</span>
<span class="c1">// @param mayPushdown True if aggregation can be pushdown down via LazyVector.</span>
<span class="c1">// The pushdown can happen only if this flag is true and &#39;args&#39; is a single</span>
<span class="c1">// LazyVector.</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">addSingleGroupIntermediateResults</span><span class="p">(</span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">group</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SelectivityVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VectorPtr</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">,</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">mayPushdown</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Finally, we can implement optional methods for converting raw inputs into intermediate
results. If partial aggregation encounters mostly unique keys and not able to meaningfully
reduce cardinality, the operator may decide to abandon partial aggregation. In this case,
the operator first emits already accumulated data (as in the case of flushing due to memory
pressure), then converts each new batch of input into intermediate results and emit it right
away. By default, to convert raw inputs into intermediate results, the operator creates fake
groups, one per input row, initializes these groups by calling initializeNewGroups,
adds each row to its own group using addRawInput, then calls extractAccumulators. This works,
but is not very efficient. Individual aggregate functions can provide a more efficient
implementation by implementing toIntermediate() method. If they decide to do so, they should
also override supportsToIntermediate() method. For example, min and max aggregate functions
implement toIntermediate() method which simply returns the input unmodified.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Returns true if toIntermediate() is supported.</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">supportsToIntermediate</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Produces an accumulator initialized from a single value for each</span>
<span class="c1">/// row in &#39;rows&#39;. The raw arguments of the aggregate are in &#39;args&#39;,</span>
<span class="c1">/// which have the same meaning as in addRawInput. The result is</span>
<span class="c1">/// placed in &#39;result&#39;. &#39;result&#39; is expected to be a writable flat vector of</span>
<span class="c1">/// the right type.</span>
<span class="c1">///</span>
<span class="c1">/// @param rows A set of rows to produce intermediate results for. The</span>
<span class="c1">/// &#39;result&#39; is expected to have rows.size() rows. Invalid rows represent rows</span>
<span class="c1">/// that were masked out, these need to have correct intermediate results as</span>
<span class="c1">/// well. It is possible that all entries in &#39;rows&#39; are invalid (masked out).</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">toIntermediate</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SelectivityVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VectorPtr</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">,</span>
<span class="w">    </span><span class="n">VectorPtr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VELOX_NYI</span><span class="p">(</span><span class="s">&quot;toIntermediate not supported&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>GroupBy aggregation code path is done. We proceed to global aggregation.</p>
</section>
<section id="global-aggregation">
<h3>Global aggregation<a class="headerlink" href="#global-aggregation" title="Permalink to this heading">¶</a></h3>
<p>Global aggregation is similar to group-by aggregation, but there is only one
group and one accumulator. After implementing group-by aggregation, the only
thing needed to enable global aggregation is to implement
addSingleGroupRawInput() method (addSingleGroupIntermediateResults() method is
already implemented as it is used for spilling group by).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Updates the single accumulator used for global aggregation.</span>
<span class="c1">// @param group Pointer to the start of the group row.</span>
<span class="c1">// @param allRows A contiguous range of row numbers starting from 0.</span>
<span class="c1">// @param args Data to add to the accumulators.</span>
<span class="c1">// @param mayPushdown True if aggregation can be pushdown down via LazyVector.</span>
<span class="c1">// The pushdown can happen only if this flag is true and &#39;args&#39; is a single</span>
<span class="c1">// LazyVector.</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">addSingleGroupRawInput</span><span class="p">(</span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">group</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SelectivityVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">allRows</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VectorPtr</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">,</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">mayPushdown</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Spilling is not helpful for global aggregations, hence, it is not supported. The
following table shows which methods are used in different global aggregation
workflows.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28.6%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Partial</p></th>
<th class="head"><p>Final</p></th>
<th class="head"><p>Single</p></th>
<th class="head"><p>Intermediate</p></th>
<th class="head"><p>Streaming</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>addSingleGroupRawInput</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>extractAccumulators</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>addSingleGroupIntermediateResults</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>extractValues</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
</tbody>
</table>
<p>Global aggregation is also used by the window operator. For each row, a global
accumulator is cleared (clear + initializeNewGroups), then all rows in a window
frame are added (addSingleGroupRawInput), then result is extracted
(extractValues).</p>
<p>When computing running totals, i.e. when window frame is BETWEEN UNBOUNDED
PRECEDING AND CURRENT ROW, window operator re-uses the accumulator for multiple
rows without resetting. For each row, window operator adds that row to the
accumulator, then extracts results. The aggregate function sees a repeated
sequence of addSingleGroupRawInput + extractValues calls and needs to handle
these correctly.</p>
</section>
</section>
<section id="factory-function">
<h2>Factory function<a class="headerlink" href="#factory-function" title="Permalink to this heading">¶</a></h2>
<p>We can now write a factory function that creates an instance of the new
aggregation function and register it by calling exec::registerAggregateFunction
(…) and specifying function name and signatures.</p>
<p>HashAggregation operator uses this function to create an instance of the
aggregate function. A new instance is created for each thread of execution. When
partial aggregation runs on 5 threads, it uses 5 instances of each aggregate
function.</p>
<p>Factory function takes core::AggregationNode::Step
(partial/final/intermediate/single) which tells what type of input to expect,
input type and result type.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">exec</span><span class="o">::</span><span class="n">AggregateRegistrationResult</span><span class="w"> </span><span class="nf">registerApproxPercentile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">exec</span><span class="o">::</span><span class="n">AggregateFunctionSignature</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">signatures</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">exec</span><span class="o">::</span><span class="n">registerAggregateFunction</span><span class="p">(</span>
<span class="w">      </span><span class="n">name</span><span class="p">,</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">signatures</span><span class="p">),</span>
<span class="w">      </span><span class="p">[</span><span class="n">name</span><span class="p">](</span>
<span class="w">          </span><span class="n">core</span><span class="o">::</span><span class="n">AggregationNode</span><span class="o">::</span><span class="n">Step</span><span class="w"> </span><span class="n">step</span><span class="p">,</span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TypePtr</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">argTypes</span><span class="p">,</span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="n">TypePtr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">resultType</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">exec</span><span class="o">::</span><span class="n">Aggregate</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">step</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">core</span><span class="o">::</span><span class="n">AggregationNode</span><span class="o">::</span><span class="n">Step</span><span class="o">::</span><span class="n">kIntermediate</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ApproxPercentileAggregate</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">(</span>
<span class="w">              </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">VARBINARY</span><span class="p">());</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">hasWeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argTypes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">        </span><span class="n">TypePtr</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exec</span><span class="o">::</span><span class="n">isRawInput</span><span class="p">(</span><span class="n">step</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">argTypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">resultType</span><span class="p">;</span>

<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">case</span><span class="w"> </span><span class="no">TypeKind</span><span class="o">::</span><span class="no">BIGINT</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ApproxPercentileAggregate</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;&gt;</span><span class="p">(</span>
<span class="w">                </span><span class="n">hasWeight</span><span class="p">,</span><span class="w"> </span><span class="n">resultType</span><span class="p">);</span>
<span class="w">          </span><span class="k">case</span><span class="w"> </span><span class="no">TypeKind</span><span class="o">::</span><span class="no">DOUBLE</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ApproxPercentileAggregate</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">(</span>
<span class="w">                </span><span class="n">hasWeight</span><span class="p">,</span><span class="w"> </span><span class="n">resultType</span><span class="p">);</span>
<span class="w">          </span><span class="p">...</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">});</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">FB_ANONYMOUS_VARIABLE</span><span class="p">(</span><span class="n">g_AggregateFunction</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">registerApproxPercentile</span><span class="p">(</span><span class="n">kApproxPercentile</span><span class="p">);</span>
</pre></div>
</div>
<p>If the aggregation function is implemented through the simple-function
interface, use <cite>SimpleAggregateAdapter&lt;FunctionClassName&gt;</cite> when creating the
unique pointers. Below is an example.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">exec</span><span class="o">::</span><span class="n">AggregateRegistrationResult</span><span class="w"> </span><span class="nf">registerSimpleArrayAggAggregate</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">exec</span><span class="o">::</span><span class="n">registerAggregateFunction</span><span class="p">(</span>
<span class="w">    </span><span class="n">name</span><span class="p">,</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">signatures</span><span class="p">),</span>
<span class="w">    </span><span class="p">[</span><span class="n">name</span><span class="p">](</span>
<span class="w">        </span><span class="n">core</span><span class="o">::</span><span class="n">AggregationNode</span><span class="o">::</span><span class="n">Step</span><span class="w"> </span><span class="cm">/*step*/</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TypePtr</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">argTypes</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">TypePtr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">resultType</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">core</span><span class="o">::</span><span class="n">QueryConfig</span><span class="o">&amp;</span><span class="w"> </span><span class="cm">/*config*/</span><span class="p">)</span>
<span class="w">        </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">exec</span><span class="o">::</span><span class="n">Aggregate</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">VELOX_CHECK_EQ</span><span class="p">(</span>
<span class="w">          </span><span class="n">argTypes</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;{} takes at most one argument&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SimpleAggregateAdapter</span><span class="o">&lt;</span><span class="n">SimpleArrayAggAggregate</span><span class="o">&gt;&gt;</span><span class="p">(</span>
<span class="w">          </span><span class="n">resultType</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
</pre></div>
</div>
<p>}</p>
<p>Use FunctionSignatureBuilder to create FunctionSignature instances which
describe supported signatures. Each signature includes zero or more input
types, an intermediate result type and final result type.</p>
<p>FunctionSignatureBuilder and FunctionSignature support Java-like
generics, variable number of arguments and lambdas. See more in
<a class="reference internal" href="scalar-functions.html#function-signature"><span class="std std-ref">Function signature</span></a> section of the <a class="reference internal" href="scalar-functions.html"><span class="doc">How to add a scalar function?</span></a> guide.</p>
<p>Here is an example of signatures for the <a class="reference internal" href="../functions/presto/aggregate.html#approx_percentile" title="approx_percentile"><code class="xref py py-func docutils literal notranslate"><span class="pre">approx_percentile()</span></code></a> function. This
functions takes value argument of a numeric type, an optional weight argument
of type INTEGER, and a percentage argument of type DOUBLE. The intermediate
type does not depend on the input types and is always VARBINARY. The final
result type is the same as input value type.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">inputType</span><span class="w"> </span><span class="o">:</span>
<span class="w">       </span><span class="p">{</span><span class="s">&quot;tinyint&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;smallint&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;integer&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bigint&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;real&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;double&quot;</span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// (x, double percentage) -&gt; varbinary -&gt; x</span>
<span class="w">    </span><span class="n">signatures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">exec</span><span class="o">::</span><span class="n">AggregateFunctionSignatureBuilder</span><span class="p">()</span>
<span class="w">                             </span><span class="p">.</span><span class="n">returnType</span><span class="p">(</span><span class="n">inputType</span><span class="p">)</span>
<span class="w">                             </span><span class="p">.</span><span class="n">intermediateType</span><span class="p">(</span><span class="s">&quot;varbinary&quot;</span><span class="p">)</span>
<span class="w">                             </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="n">inputType</span><span class="p">)</span>
<span class="w">                             </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;double&quot;</span><span class="p">)</span>
<span class="w">                             </span><span class="p">.</span><span class="n">build</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// (x, integer weight, double percentage) -&gt; varbinary -&gt; x</span>
<span class="w">    </span><span class="n">signatures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">exec</span><span class="o">::</span><span class="n">AggregateFunctionSignatureBuilder</span><span class="p">()</span>
<span class="w">                             </span><span class="p">.</span><span class="n">returnType</span><span class="p">(</span><span class="n">inputType</span><span class="p">)</span>
<span class="w">                             </span><span class="p">.</span><span class="n">intermediateType</span><span class="p">(</span><span class="s">&quot;varbinary&quot;</span><span class="p">)</span>
<span class="w">                             </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="n">inputType</span><span class="p">)</span>
<span class="w">                             </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;bigint&quot;</span><span class="p">)</span>
<span class="w">                             </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;double&quot;</span><span class="p">)</span>
<span class="w">                             </span><span class="p">.</span><span class="n">build</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this heading">¶</a></h2>
<p>It is time to put all the pieces together and test how well the new function
works.</p>
<p>Use AggregationTestBase from velox/aggregates/tests/AggregationTestBase.h as a
base class for the test.</p>
<p>If the new aggregate function is supported by <a class="reference external" href="https://duckdb.org/docs/sql/aggregates">DuckDB</a>, you can use DuckDB to check
results. In this case you specify input data, grouping keys, a list of
aggregates and a SQL query to run on DuckDB to calculate the expected results
and call helper function testAggregates defined in AggregationTestBase class.
Grouping keys can be empty for global aggregations.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Global aggregation.</span>
<span class="n">testAggregations</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;sum(c1)&quot;</span><span class="p">},</span><span class="w"> </span><span class="s">&quot;SELECT sum(c1) FROM tmp&quot;</span><span class="p">);</span>

<span class="c1">// Group by aggregation.</span>
<span class="n">testAggregations</span><span class="p">(</span>
<span class="w">    </span><span class="n">vectors</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;c0&quot;</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;sum(c1)&quot;</span><span class="p">},</span><span class="w"> </span><span class="s">&quot;SELECT c0, sum(c1) FROM tmp GROUP BY 1&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>If the new function is not supported by DuckDB, you need to specify the expected
results manually.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Global aggregation.</span>
<span class="n">testAggregations</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;map_union(c1)&quot;</span><span class="p">},</span><span class="w"> </span><span class="n">expectedResult</span><span class="p">);</span>

<span class="c1">// Group by aggregation.</span>
<span class="n">testAggregations</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;c0&quot;</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;map_union(c1)&quot;</span><span class="p">},</span><span class="w"> </span><span class="n">expectedResult</span><span class="p">);</span>
</pre></div>
</div>
<p>Under the covers, testAggregations method generates multiple different but
logically equivalent plans, executes these plans, verifies successful
completion and compares the results with DuckDB or specified expected results.</p>
<p>The following query plans are being tested.</p>
<ul class="simple">
<li><p>Partial aggregation followed by final aggregation. Query runs
single-threaded.</p></li>
<li><p>Single aggregation. Query runs single-threaded.</p></li>
<li><p>Partial aggregation followed by intermediate aggregation followed by final
aggregation. Query runs single-threaded.</p></li>
<li><p>Partial aggregation followed by local exchange on the grouping keys followed
by final aggregation. Query runs using 4 threads.</p></li>
<li><p>Local exchange using round-robin repartitioning followed by partial
aggregation followed by local exchange on the grouping keys followed by
final aggregation with forced spilling. Query runs using 4 threads.</p></li>
</ul>
<p>Query run with forced spilling is enabled only for group-by aggregations and
only if <cite>allowInputShuffle_</cite> flag is enabled by calling allowInputShuffle
() method from the SetUp(). Spill testing requires multiple batches of input.
To split input data into multiple batches we add local exchange with
round-robin repartitioning before the partial aggregation. This changes the order
in which aggregation inputs are processed, hence, query results with spilling
are expected to be the same as without spilling only if aggregate functions used
in the query are not sensitive to the order of inputs. Many functions produce
the same results regardless of the order of inputs, but some functions may return
different results if inputs are provided in a different order. For
example, <a class="reference internal" href="../functions/presto/aggregate.html#arbitrary" title="arbitrary"><code class="xref py py-func docutils literal notranslate"><span class="pre">arbitrary()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#array_agg" title="array_agg"><code class="xref py py-func docutils literal notranslate"><span class="pre">array_agg()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#map_agg" title="map_agg"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_agg()</span></code></a> and
<a class="reference internal" href="../functions/presto/aggregate.html#map_union" title="map_union"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_union()</span></code></a> functions are sensitive to the order of inputs,
and <a class="reference internal" href="../functions/presto/aggregate.html#min_by" title="min_by"><code class="xref py py-func docutils literal notranslate"><span class="pre">min_by()</span></code></a> and <a class="reference internal" href="../functions/presto/aggregate.html#max_by" title="max_by"><code class="xref py py-func docutils literal notranslate"><span class="pre">max_by()</span></code></a> functions are sensitive to the order of
inputs in the presence of ties.</p>
</section>
<section id="function-names">
<h2>Function names<a class="headerlink" href="#function-names" title="Permalink to this heading">¶</a></h2>
<p>Same as scalar functions, aggregate function names are case insensitive. The names
are converted to lower case automatically when the functions are registered and
when they are resolved for a given expression.</p>
</section>
<section id="documentation">
<h2>Documentation<a class="headerlink" href="#documentation" title="Permalink to this heading">¶</a></h2>
<p>Finally, document the new function by adding an entry to velox/docs/functions/presto/aggregate.rst</p>
<p>You can see the documentation for all functions at <a class="reference internal" href="../functions/presto/aggregate.html"><span class="doc">Aggregate Functions</span></a> and read about how documentation is generated at <a class="reference external" href="https://github.com/facebookincubator/velox/tree/main/velox/docs#velox-documentation">https://github.com/facebookincubator/velox/tree/main/velox/docs#velox-documentation</a></p>
</section>
<section id="accumulator">
<h2>Accumulator<a class="headerlink" href="#accumulator" title="Permalink to this heading">¶</a></h2>
<p>In Velox, efficient use of memory is a priority. This includes both optimizing
the total amount of memory used as well as the number of memory allocations.
Note that runtime statistics reported by Velox include both peak memory usage
(in bytes) and number of memory allocations for each operator.</p>
<p>Aggregate functions use memory to store intermediate results in the
accumulators. They allocate memory from an arena (<a class="reference internal" href="arena.html"><span class="doc">HashStringAllocator</span></a> class).</p>
<p>StlAllocator is an STL-compatible allocator backed by HashStringAllocator that
can be used with STL containers. For example, one can define an std::vector
that allocates memory from the arena like so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="p">,</span><span class="w"> </span><span class="n">StlAllocator</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;&gt;</span>
</pre></div>
</div>
<p>This is used, for example, in 3-arg versions of <a class="reference internal" href="../functions/presto/aggregate.html#min_by" title="min_by"><code class="xref py py-func docutils literal notranslate"><span class="pre">min_by()</span></code></a> and <a class="reference internal" href="../functions/presto/aggregate.html#max_by" title="max_by"><code class="xref py py-func docutils literal notranslate"><span class="pre">max_by()</span></code></a> with
fixed-width type inputs (e.g. integers).</p>
<p>There is also an AlignedStlAllocator that provides aligned allocations from the
arena and can be used with <a class="reference external" href="https://engineering.fb.com/2019/04/25/developer-tools/f14/">F14</a>
containers which require 16-byte alignment. One can define an F14FastMap that
allocates memory from the arena like so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">folly</span><span class="o">::</span><span class="n">F14FastMap</span><span class="o">&lt;</span>
<span class="w">      </span><span class="kt">int64_t</span><span class="p">,</span>
<span class="w">      </span><span class="kt">double</span><span class="p">,</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="n">AlignedStlAllocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="o">&gt;&gt;</span>
</pre></div>
</div>
<p>You can find an example usage in <a class="reference internal" href="../functions/presto/aggregate.html#histogram" title="histogram"><code class="xref py py-func docutils literal notranslate"><span class="pre">histogram()</span></code></a> aggregation function.</p>
<p>An <a class="reference internal" href="../functions/presto/aggregate.html#array_agg" title="array_agg"><code class="xref py py-func docutils literal notranslate"><span class="pre">array_agg()</span></code></a> function on primitive types could be implemented using
std::vector&lt;T&gt;, but it would not be efficient. Why is that? If one doesn’t
use ‘reserve’ method to provide a hint to std::vector about how many entries will be
added, the default behavior is to allocate memory in powers of 2, e.g. first
allocate 1 entry, then 2, then 4, 8, 16, etc. Every time new allocation is
made the data is copied into the new memory buffer and the old buffer is
released. One can see this by instrumenting StlAllocator::allocate and
deallocate methods to add logging and run a simple loop to add elements to a
vector:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">StlAllocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">(</span>
<span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">StlAllocator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allocator_</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>


<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>E20230714 14:57:33.717708 975289 HashStringAllocator.h:497] allocate 1
E20230714 14:57:33.734280 975289 HashStringAllocator.h:497] allocate 2
E20230714 14:57:33.734321 975289 HashStringAllocator.h:506] free 1
E20230714 14:57:33.734352 975289 HashStringAllocator.h:497] allocate 4
E20230714 14:57:33.734381 975289 HashStringAllocator.h:506] free 2
E20230714 14:57:33.734416 975289 HashStringAllocator.h:497] allocate 8
E20230714 14:57:33.734445 975289 HashStringAllocator.h:506] free 4
E20230714 14:57:33.734481 975289 HashStringAllocator.h:497] allocate 16
E20230714 14:57:33.734513 975289 HashStringAllocator.h:506] free 8
E20230714 14:57:33.734544 975289 HashStringAllocator.h:497] allocate 32
E20230714 14:57:33.734575 975289 HashStringAllocator.h:506] free 16
E20230714 14:57:33.734606 975289 HashStringAllocator.h:497] allocate 64
E20230714 14:57:33.734637 975289 HashStringAllocator.h:506] free 32
E20230714 14:57:33.734668 975289 HashStringAllocator.h:497] allocate 128
E20230714 14:57:33.734699 975289 HashStringAllocator.h:506] free 64
E20230714 14:57:33.734731 975289 HashStringAllocator.h:506] free 128
</pre></div>
</div>
<p>Reallocating memory and copying data is not cheap. To avoid this overhead we
introduced ValueList primitive and used it to implement array_agg.</p>
<p>ValueList is an append-only data structure that allows appending values from any
Velox Vector and reading values back into a Velox Vector. ValueList doesn’t
require a contiguous chunk of memory and therefore doesn’t need to re-allocate
and copy when it runs out of space. It just allocates another chunk and starts
filling that up.</p>
<p>ValueList is designed to work with data that comes from Velox Vectors, hence,
its API is different from std::vector. You append values from a DecodedVector
and read values back into a flat vector. Here is an example of usage:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">DecodedVector</span><span class="w"> </span><span class="nf">decoded</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="c1">// Store data.</span>
<span class="n">ValueList</span><span class="w"> </span><span class="n">values</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="n">values</span><span class="p">.</span><span class="n">appendValue</span><span class="p">(</span><span class="n">decoded</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">allocator</span><span class="p">());</span>
<span class="p">}</span>


<span class="c1">// Read data back.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BaseVector</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">DOUBLE</span><span class="p">(),</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="n">pool</span><span class="p">());</span>
<span class="n">aggregate</span><span class="o">::</span><span class="n">ValueListReader</span><span class="w"> </span><span class="nf">reader</span><span class="p">(</span><span class="n">values</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="n">reader</span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ValueList supports all types, so you can use it to append fixed-width values as
well as strings, arrays, maps and structs.</p>
<p>When storing complex types, ValueList serializes the values using
ContainerRowSerde.</p>
<p>ValueList preserves the null flags as well, so you can store a list of nullable
values in it.</p>
<p>The array_agg is implemented using ValueList for the accumulator.</p>
<p>ValueList needs a pointer to the arena for appending data. It doesn’t take an
arena in the constructor and doesn’t store it, because that would require 8
bytes of memory per group in the aggregation operator. Instead,
ValueList::appendValue method takes a pointer to the arena as an argument.
Consequently, ValueList’s destructor cannot release the memory back to the
arena and requires the user to explicitly call the free
(HashStringAllocator*) method.</p>
<p><a class="reference internal" href="../functions/presto/aggregate.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a> and <a class="reference internal" href="../functions/presto/aggregate.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> functions store a single value in the accumulator
(the current min or max value). They use SingleValueAccumulator to store
strings, arrays, maps and structs. When processing a new value, we compare
it with the stored value and replace the stored value if necessary.</p>
<p>Similar to ValueList, SingleValueAccumulator serializes the values using
ContainerRowSerde. SingleValueAccumulator provides a compare method to compare
stored value with a row of a DecodedVector.</p>
<p>This accumulator is also used in the implementation of the <a class="reference internal" href="../functions/presto/aggregate.html#arbitrary" title="arbitrary"><code class="xref py py-func docutils literal notranslate"><span class="pre">arbitrary()</span></code></a>
aggregate function which stores the first value in the accumulator.</p>
<p><a class="reference internal" href="../functions/presto/aggregate.html#set_agg" title="set_agg"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_agg()</span></code></a> function accumulates a set of unique values into an F14FastSet
configured to allocate memory from the arena via AlignedStlAllocator.
Fixed-width values are stored directly in F14FastSet. Memory allocation pattern
for F14 data structures is similar to std::vector. F14 allocates memory in
powers on 2, copies data and frees previously allocated memory. Hence, we do
not store strings directly in the F14 set. Instead, Velox writes strings into
the arena and stores a StringView pointing to the arena in the set.</p>
<p>In general, when writing to the arena, one is not guaranteed a contiguous write.
However, for StringViews to work we must ensure that strings written into the
arena are contiguous. Strings helper class provides this functionality. Its
append method takes a StringView and a pointer to the arena, copies the string
into the arena and returns a StringView pointing to the copy.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Copies the string into contiguous memory allocated via</span>
<span class="c1">/// HashStringAllocator. Returns StringView over the copy.</span>
<span class="n">StringView</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="n">StringView</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">HashStringAllocator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">allocator</span><span class="p">);</span>
</pre></div>
</div>
<p>Strings class provides a free method to release memory back to the arena.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Frees memory used by the strings. StringViews returned from &#39;append&#39;</span>
<span class="c1">/// become invalid after this call.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">free</span><span class="p">(</span><span class="n">HashStringAllocator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">allocator</span><span class="p">);</span>
</pre></div>
</div>
<p>When aggregating complex types (arrays, maps or structs), we use
AddressableNonNullValueList which writes values to the arena and returns
a “pointer” to the written value which we store in the F14 set.
AddressableNonNullValueList provides methods to compute a hash of a value and
compare two values. AddressableNonNullValueList uses ContainerRowSerde for
serializing data and comparing serialized values.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// A set of pointers to values stored in AddressableNonNullValueList.</span>
<span class="n">SetAccumulator</span><span class="o">&lt;</span>
<span class="w">   </span><span class="n">HashStringAllocator</span><span class="o">::</span><span class="n">Position</span><span class="p">,</span>
<span class="w">   </span><span class="n">AddressableNonNullValueList</span><span class="o">::</span><span class="n">Hash</span><span class="p">,</span>
<span class="w">   </span><span class="n">AddressableNonNullValueList</span><span class="o">::</span><span class="n">EqualTo</span><span class="o">&gt;</span>
<span class="w">   </span><span class="n">base</span><span class="p">;</span>
</pre></div>
</div>
<p>AddressableNonNullValueList allows to append a value and erase the last value.
This functionality is sufficient for set_agg and set_union. When processing a
new value, we append it to the list, get a “pointer”, insert that “pointer”
into F14 set and if the “pointer” points to a duplicate value we remove it from
the list.</p>
<p>Like all other arena-based accumulators, AddressableNonNullValueList provides a
free method to return memory back to the arena.</p>
<p>Note: AddressableNonNullValueList is different from ValueList in that it
provides access to individual values (hence, the “Addressable” prefix in the
name) while ValueList does not. With ValueList one can append values, then copy
all the values into a Vector. Adhoc access to individual elements is not
available in ValueList.</p>
<p>SetAccumulator&lt;T&gt; template implements a simple interface to accumulate unique
values. It is implemented using F14FastSet, Strings and
AddressableNonNullValueList. T can be a fixed-width type like int32_t or
int64_t, StringView or ComplexType.</p>
<p>addValue and addValues method allow to add one or multiple values from a vector.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Adds value if new. No-op if the value was added before.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">addValue</span><span class="p">(</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">DecodedVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">decoded</span><span class="p">,</span>
<span class="w">   </span><span class="n">vector_size_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span>
<span class="w">   </span><span class="n">HashStringAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">allocator</span><span class="p">)</span><span class="c1">/// Adds new values from an array.</span>

<span class="kt">void</span><span class="w"> </span><span class="n">addValues</span><span class="p">(</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">ArrayVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">arrayVector</span><span class="p">,</span>
<span class="w">   </span><span class="n">vector_size_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">DecodedVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">values</span><span class="p">,</span>
<span class="w">   </span><span class="n">HashStringAllocator</span><span class="o">*</span><span class="w"> </span><span class="n">allocator</span><span class="p">)</span>
</pre></div>
</div>
<p>size() method returns the number of unique values.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Returns number of unique values including null.</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
</pre></div>
</div>
<p>extractValues method allows to extract unique values into a vector.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Copies the unique values and null into the specified vector starting at</span>
<span class="c1">/// the specified offset.</span>
<span class="n">vector_size_t</span><span class="w"> </span><span class="n">extractValues</span><span class="p">(</span><span class="n">FlatVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">vector_size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span>

<span class="c1">/// For complex types.</span>
<span class="n">vector_size_t</span><span class="w"> </span><span class="n">extractValues</span><span class="p">(</span><span class="n">BaseVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">vector_size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>Both <a class="reference internal" href="../functions/presto/aggregate.html#set_agg" title="set_agg"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_agg()</span></code></a> and <a class="reference internal" href="../functions/presto/aggregate.html#set_union" title="set_union"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_union()</span></code></a> functions are implemented using
SetAccumulator.</p>
<p><a class="reference internal" href="../functions/presto/aggregate.html#map_agg" title="map_agg"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_agg()</span></code></a> function accumulates keys and values into a map. It discards
duplicate keys and keeps only one value for each unique key. Map_agg uses
MapAccumulator&lt;T&gt; template to accumulate the values. Similar to SetAccumulator,
MapAccumulator is built using F14FastMap, AlignedStlAllocator, Strings and
AddressableNonNullValueList.</p>
<p>insert() method adds a pair of (key, value) to the map discarding the value if matching key already exists.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Adds key-value pair if entry with that key doesn&#39;t exist yet.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">DecodedVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">decodedKeys</span><span class="p">,</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">DecodedVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">decodedValues</span><span class="p">,</span>
<span class="w">   </span><span class="n">vector_size_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span>
<span class="w">   </span><span class="n">HashStringAllocator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">allocator</span><span class="p">)</span>
</pre></div>
</div>
<p>size() method returns the number of unique values.</p>
<p>extract() method copies the keys and the values into vectors, which can be combined to form a MapVector.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">extract</span><span class="p">(</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">VectorPtr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mapKeys</span><span class="p">,</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">VectorPtr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mapValues</span><span class="p">,</span>
<span class="w">   </span><span class="n">vector_size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>Both <a class="reference internal" href="../functions/presto/aggregate.html#map_agg" title="map_agg"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_agg()</span></code></a> and <a class="reference internal" href="../functions/presto/aggregate.html#map_union" title="map_union"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_union()</span></code></a> functions are implemented using
MapAccumulator.</p>
<p>When implementing new aggregate functions, consider using ValueList,
SingleValueAccumulator, Strings, AddressableNonNullValueList and F14
containers to put together an accumulator that uses memory efficiently.</p>
<p>Aggregation operator needs to know how much memory is used for each group.
For example, this information is used to decide how many and which rows to
spill when memory is tight.</p>
<p>Aggregation functions should use RowSizeTracker to help track memory usage
per group. Aggregate base class provides helper method trackRowSize(group),
which can be used like so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span><span class="p">.</span><span class="n">applyToSelected</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">vector_size_t</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">groups</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tracker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trackRowSize</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
<span class="w">    </span><span class="n">accumulator</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(...);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The ‘trackRowSize’ method returns an instance of RowSizeTracker initialized
with a reference to the arena and a counter to increment on destruction. When
object returned by trackRowSize goes out of scope, the counter is updated to
add memory allocated since object’s creation.</p>
</section>
<section id="end-to-end-testing">
<h2>End-to-End Testing<a class="headerlink" href="#end-to-end-testing" title="Permalink to this heading">¶</a></h2>
<p>To confirm that aggregate function works end to end as part of query, update testAggregations() test in TestHiveAggregationQueries.java in presto_cpp repo to add a query that uses the new function.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">assertQuery</span><span class="p">(</span><span class="s">&quot;SELECT orderkey, array_agg(linenumber) FROM lineitem GROUP BY 1&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="overwrite-intermediate-type-in-presto">
<h2>Overwrite Intermediate Type in Presto<a class="headerlink" href="#overwrite-intermediate-type-in-presto" title="Permalink to this heading">¶</a></h2>
<p>Sometimes we need to change the intermediate type of aggregation function in
Presto, due to the differences in implementation or in the type information
worker node receives.  This is done in Presto class
<code class="docutils literal notranslate"><span class="pre">com.facebook.presto.metadata.BuiltInTypeAndFunctionNamespaceManager</span></code>.  When
<code class="docutils literal notranslate"><span class="pre">FeaturesConfig.isUseAlternativeFunctionSignatures()</span></code> is enabled, we can
register a different set of function signatures used specifically by Velox.  An
example of how to create such alternative function signatures from scratch can
be found in
<code class="docutils literal notranslate"><span class="pre">com.facebook.presto.operator.aggregation.AlternativeApproxPercentile</span></code>.  An
example pull request can be found at
<a class="reference external" href="https://github.com/prestodb/presto/pull/18386">https://github.com/prestodb/presto/pull/18386</a>.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">How to add an aggregate function?</a><ul>
<li><a class="reference internal" href="#memory-layout">Memory Layout</a></li>
<li><a class="reference internal" href="#simple-function-interface">Simple Function Interface</a><ul>
<li><a class="reference internal" href="#default-null-behavior">Default-Null Behavior</a></li>
<li><a class="reference internal" href="#tointermediate">toIntermediate</a></li>
<li><a class="reference internal" href="#accumulatortype-of-default-null-behavior">AccumulatorType of Default-Null Behavior</a><ul>
<li><a class="reference internal" href="#addinput">addInput</a></li>
<li><a class="reference internal" href="#combine">combine</a></li>
<li><a class="reference internal" href="#writeintermediateresult">writeIntermediateResult</a></li>
<li><a class="reference internal" href="#writefinalresult">writeFinalResult</a></li>
</ul>
</li>
<li><a class="reference internal" href="#accumulatortype-of-non-default-null-behavior">AccumulatorType of Non-Default-Null Behavior</a><ul>
<li><a class="reference internal" href="#id1">addInput</a></li>
<li><a class="reference internal" href="#id2">combine</a></li>
<li><a class="reference internal" href="#id3">writeIntermediateResult</a></li>
<li><a class="reference internal" href="#id4">writeFinalResult</a></li>
</ul>
</li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vector-function-interface">Vector Function Interface</a><ul>
<li><a class="reference internal" href="#accumulator-size">Accumulator size</a></li>
<li><a class="reference internal" href="#initialization">Initialization</a></li>
<li><a class="reference internal" href="#groupby-aggregation">GroupBy aggregation</a></li>
<li><a class="reference internal" href="#global-aggregation">Global aggregation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#factory-function">Factory function</a></li>
<li><a class="reference internal" href="#testing">Testing</a></li>
<li><a class="reference internal" href="#function-names">Function names</a></li>
<li><a class="reference internal" href="#documentation">Documentation</a></li>
<li><a class="reference internal" href="#accumulator">Accumulator</a></li>
<li><a class="reference internal" href="#end-to-end-testing">End-to-End Testing</a></li>
<li><a class="reference internal" href="#overwrite-intermediate-type-in-presto">Overwrite Intermediate Type in Presto</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="scalar-functions.html"
                          title="previous chapter">How to add a scalar function?</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="view-and-writer-types.html"
                          title="next chapter">View and Writer Types</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/develop/aggregate-functions.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="view-and-writer-types.html" title="View and Writer Types"
             >next</a> |</li>
        <li class="right" >
          <a href="scalar-functions.html" title="How to add a scalar function?"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" >Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to add an aggregate function?</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright TBD.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.2.0.
    </div>
  </body>
</html>